{"ast":null,"code":"/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.localizeStyle = localizeStyle;\nvar cache = new WeakMap();\nvar markerProp = '$$css$localize';\n/**\n * The compiler polyfills logical properties and values, generating a class\n * name for both writing directions. The style objects are annotated by\n * the compiler as needing this runtime transform. The results are memoized.\n *\n * { '$$css$localize': true, float: [ 'float-left', 'float-right' ] }\n * => { float: 'float-left' }\n */\n\nfunction compileStyle(style, isRTL) {\n  // Create a new compiled style for styleq\n  var compiledStyle = {};\n  for (var prop in style) {\n    if (prop !== markerProp) {\n      var value = style[prop];\n      if (Array.isArray(value)) {\n        compiledStyle[prop] = isRTL ? value[1] : value[0];\n      } else {\n        compiledStyle[prop] = value;\n      }\n    }\n  }\n  return compiledStyle;\n}\nfunction localizeStyle(style, isRTL) {\n  if (style[markerProp] != null) {\n    var compiledStyleIndex = isRTL ? 1 : 0; // Check the cache in case we've already seen this object\n\n    if (cache.has(style)) {\n      var _cachedStyles = cache.get(style);\n      var _compiledStyle = _cachedStyles[compiledStyleIndex];\n      if (_compiledStyle == null) {\n        // Update the missing cache entry\n        _compiledStyle = compileStyle(style, isRTL);\n        _cachedStyles[compiledStyleIndex] = _compiledStyle;\n        cache.set(style, _cachedStyles);\n      }\n      return _compiledStyle;\n    } // Create a new compiled style for styleq\n\n    var compiledStyle = compileStyle(style, isRTL);\n    var cachedStyles = new Array(2);\n    cachedStyles[compiledStyleIndex] = compiledStyle;\n    cache.set(style, cachedStyles);\n    return compiledStyle;\n  }\n  return style;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","localizeStyle","cache","WeakMap","markerProp","compileStyle","style","isRTL","compiledStyle","prop","Array","isArray","compiledStyleIndex","has","_cachedStyles","get","_compiledStyle","set","cachedStyles"],"sources":["C:/Users/dlfrn/Downloads/myToyProj/toyProject/FrontEnd/alcohol-app/node_modules/styleq/dist/transform-localize-style.js"],"sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.localizeStyle = localizeStyle;\nvar cache = new WeakMap();\nvar markerProp = '$$css$localize';\n/**\n * The compiler polyfills logical properties and values, generating a class\n * name for both writing directions. The style objects are annotated by\n * the compiler as needing this runtime transform. The results are memoized.\n *\n * { '$$css$localize': true, float: [ 'float-left', 'float-right' ] }\n * => { float: 'float-left' }\n */\n\nfunction compileStyle(style, isRTL) {\n  // Create a new compiled style for styleq\n  var compiledStyle = {};\n\n  for (var prop in style) {\n    if (prop !== markerProp) {\n      var value = style[prop];\n\n      if (Array.isArray(value)) {\n        compiledStyle[prop] = isRTL ? value[1] : value[0];\n      } else {\n        compiledStyle[prop] = value;\n      }\n    }\n  }\n\n  return compiledStyle;\n}\n\nfunction localizeStyle(style, isRTL) {\n  if (style[markerProp] != null) {\n    var compiledStyleIndex = isRTL ? 1 : 0; // Check the cache in case we've already seen this object\n\n    if (cache.has(style)) {\n      var _cachedStyles = cache.get(style);\n\n      var _compiledStyle = _cachedStyles[compiledStyleIndex];\n\n      if (_compiledStyle == null) {\n        // Update the missing cache entry\n        _compiledStyle = compileStyle(style, isRTL);\n        _cachedStyles[compiledStyleIndex] = _compiledStyle;\n        cache.set(style, _cachedStyles);\n      }\n\n      return _compiledStyle;\n    } // Create a new compiled style for styleq\n\n\n    var compiledStyle = compileStyle(style, isRTL);\n    var cachedStyles = new Array(2);\n    cachedStyles[compiledStyleIndex] = compiledStyle;\n    cache.set(style, cachedStyles);\n    return compiledStyle;\n  }\n\n  return style;\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,aAAa,GAAGA,aAAa;AACrC,IAAIC,KAAK,GAAG,IAAIC,OAAO,CAAC,CAAC;AACzB,IAAIC,UAAU,GAAG,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,YAAYA,CAACC,KAAK,EAAEC,KAAK,EAAE;EAClC;EACA,IAAIC,aAAa,GAAG,CAAC,CAAC;EAEtB,KAAK,IAAIC,IAAI,IAAIH,KAAK,EAAE;IACtB,IAAIG,IAAI,KAAKL,UAAU,EAAE;MACvB,IAAIJ,KAAK,GAAGM,KAAK,CAACG,IAAI,CAAC;MAEvB,IAAIC,KAAK,CAACC,OAAO,CAACX,KAAK,CAAC,EAAE;QACxBQ,aAAa,CAACC,IAAI,CAAC,GAAGF,KAAK,GAAGP,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC;MACnD,CAAC,MAAM;QACLQ,aAAa,CAACC,IAAI,CAAC,GAAGT,KAAK;MAC7B;IACF;EACF;EAEA,OAAOQ,aAAa;AACtB;AAEA,SAASP,aAAaA,CAACK,KAAK,EAAEC,KAAK,EAAE;EACnC,IAAID,KAAK,CAACF,UAAU,CAAC,IAAI,IAAI,EAAE;IAC7B,IAAIQ,kBAAkB,GAAGL,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;;IAExC,IAAIL,KAAK,CAACW,GAAG,CAACP,KAAK,CAAC,EAAE;MACpB,IAAIQ,aAAa,GAAGZ,KAAK,CAACa,GAAG,CAACT,KAAK,CAAC;MAEpC,IAAIU,cAAc,GAAGF,aAAa,CAACF,kBAAkB,CAAC;MAEtD,IAAII,cAAc,IAAI,IAAI,EAAE;QAC1B;QACAA,cAAc,GAAGX,YAAY,CAACC,KAAK,EAAEC,KAAK,CAAC;QAC3CO,aAAa,CAACF,kBAAkB,CAAC,GAAGI,cAAc;QAClDd,KAAK,CAACe,GAAG,CAACX,KAAK,EAAEQ,aAAa,CAAC;MACjC;MAEA,OAAOE,cAAc;IACvB,CAAC,CAAC;;IAGF,IAAIR,aAAa,GAAGH,YAAY,CAACC,KAAK,EAAEC,KAAK,CAAC;IAC9C,IAAIW,YAAY,GAAG,IAAIR,KAAK,CAAC,CAAC,CAAC;IAC/BQ,YAAY,CAACN,kBAAkB,CAAC,GAAGJ,aAAa;IAChDN,KAAK,CAACe,GAAG,CAACX,KAAK,EAAEY,YAAY,CAAC;IAC9B,OAAOV,aAAa;EACtB;EAEA,OAAOF,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}