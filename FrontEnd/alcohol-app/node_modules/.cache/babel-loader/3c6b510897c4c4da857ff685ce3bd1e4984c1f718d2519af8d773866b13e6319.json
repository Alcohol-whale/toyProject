{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar DELAY = 'DELAY';\nvar ERROR = 'ERROR';\nvar LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';\nvar NOT_RESPONDER = 'NOT_RESPONDER';\nvar RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';\nvar RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';\nvar RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';\nvar RESPONDER_GRANT = 'RESPONDER_GRANT';\nvar RESPONDER_RELEASE = 'RESPONDER_RELEASE';\nvar RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';\nvar Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: ERROR,\n    RESPONDER_TERMINATED: ERROR,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_START: {\n    DELAY: RESPONDER_ACTIVE_PRESS_START,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  ERROR: {\n    DELAY: NOT_RESPONDER,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: NOT_RESPONDER\n  }\n});\nvar isActiveSignal = signal => signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\nvar isButtonRole = element => element.getAttribute('role') === 'button';\nvar isPressStartSignal = signal => signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\nvar isTerminalSignal = signal => signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;\nvar isValidKeyPress = event => {\n  var key = event.key,\n    target = event.target;\n  var role = target.getAttribute('role');\n  var isSpacebar = key === ' ' || key === 'Spacebar';\n  return key === 'Enter' || isSpacebar && role === 'button';\n};\nvar DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50\n\nvar DEFAULT_PRESS_DELAY_MS = 50;\n/**\n * =========================== PressResponder Tutorial ===========================\n *\n * The `PressResponder` class helps you create press interactions by analyzing the\n * geometry of elements and observing when another responder (e.g. ScrollView)\n * has stolen the touch lock. It offers hooks for your component to provide\n * interaction feedback to the user:\n *\n * - When a press has activated (e.g. highlight an element)\n * - When a press has deactivated (e.g. un-highlight an element)\n * - When a press sould trigger an action, meaning it activated and deactivated\n *   while within the geometry of the element without the lock being stolen.\n *\n * A high quality interaction isn't as simple as you might think. There should\n * be a slight delay before activation. Moving your finger beyond an element's\n * bounds should trigger deactivation, but moving the same finger back within an\n * element's bounds should trigger reactivation.\n *\n * In order to use `PressResponder`, do the following:\n *\n *     const pressResponder = new PressResponder(config);\n *\n * 2. Choose the rendered component who should collect the press events. On that\n *    element, spread `pressability.getEventHandlers()` into its props.\n *\n *    return (\n *      <View {...this.state.pressResponder.getEventHandlers()} />\n *    );\n *\n * 3. Reset `PressResponder` when your component unmounts.\n *\n *    componentWillUnmount() {\n *      this.state.pressResponder.reset();\n *    }\n *\n * ==================== Implementation Details ====================\n *\n * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n * # Geometry\n *\n *  ┌────────────────────────┐\n *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`.\n *  │  │  ┌────────────┐  │  │\n *  │  │  │ VisualRect │  │  │\n *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time\n *  │  │    HitRect       │  │   before letting up, `VisualRect` activates.\n *  │  └──────────────────┘  │\n *  │       Out Region   o   │\n *  └────────────────────│───┘\n *                       └────── When the press is released outside the `HitRect`,\n *                               the responder is NOT eligible for a \"press\".\n *\n * # State Machine\n *\n * ┌───────────────┐ ◀──── RESPONDER_RELEASE\n * │ NOT_RESPONDER │\n * └───┬───────────┘ ◀──── RESPONDER_TERMINATED\n *     │\n *     │ RESPONDER_GRANT (HitRect)\n *     │\n *     ▼\n * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐\n * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │\n * │ PRESS_START         ├────────▶ │ PRESS_START       ├────────────▶ │ LONG_PRESS_START  │\n * └─────────────────────┘          └───────────────────┘              └───────────────────┘\n *\n * T + DELAY => LONG_PRESS_DELAY + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the invocation of `onLongPress`. Only when the browser produces a\n * `click` event is `onPress` invoked.\n */\n\nexport default class PressResponder {\n  constructor(config) {\n    this._eventHandlers = null;\n    this._isPointerTouch = false;\n    this._longPressDelayTimeout = null;\n    this._longPressDispatched = false;\n    this._pressDelayTimeout = null;\n    this._pressOutDelayTimeout = null;\n    this._touchState = NOT_RESPONDER;\n    this.configure(config);\n  }\n  configure(config) {\n    this._config = config;\n  }\n  /**\n   * Resets any pending timers. This should be called on unmount.\n   */\n\n  reset() {\n    this._cancelLongPressDelayTimeout();\n    this._cancelPressDelayTimeout();\n    this._cancelPressOutDelayTimeout();\n  }\n  /**\n   * Returns a set of props to spread into the interactive element.\n   */\n\n  getEventHandlers() {\n    if (this._eventHandlers == null) {\n      this._eventHandlers = this._createEventHandlers();\n    }\n    return this._eventHandlers;\n  }\n  _createEventHandlers() {\n    var start = (event, shouldDelay) => {\n      event.persist();\n      this._cancelPressOutDelayTimeout();\n      this._longPressDispatched = false;\n      this._selectionTerminated = false;\n      this._touchState = NOT_RESPONDER;\n      this._isPointerTouch = event.nativeEvent.type === 'touchstart';\n      this._receiveSignal(RESPONDER_GRANT, event);\n      var delayPressStart = normalizeDelay(this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);\n      if (shouldDelay !== false && delayPressStart > 0) {\n        this._pressDelayTimeout = setTimeout(() => {\n          this._receiveSignal(DELAY, event);\n        }, delayPressStart);\n      } else {\n        this._receiveSignal(DELAY, event);\n      }\n      var delayLongPress = normalizeDelay(this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);\n      this._longPressDelayTimeout = setTimeout(() => {\n        this._handleLongPress(event);\n      }, delayLongPress + delayPressStart);\n    };\n    var end = event => {\n      this._receiveSignal(RESPONDER_RELEASE, event);\n    };\n    var keyupHandler = event => {\n      var onPress = this._config.onPress;\n      var target = event.target;\n      if (this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {\n        end(event);\n        document.removeEventListener('keyup', keyupHandler);\n        var role = target.getAttribute('role');\n        var elementType = target.tagName.toLowerCase();\n        var isNativeInteractiveElement = role === 'link' || elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea';\n        if (onPress != null && !isNativeInteractiveElement) {\n          onPress(event);\n        }\n      }\n    };\n    return {\n      onStartShouldSetResponder: event => {\n        var disabled = this._config.disabled;\n        if (disabled && isButtonRole(event.currentTarget)) {\n          event.stopPropagation();\n        }\n        if (disabled == null) {\n          return true;\n        }\n        return !disabled;\n      },\n      onKeyDown: event => {\n        var disabled = this._config.disabled;\n        var key = event.key,\n          target = event.target;\n        if (!disabled && isValidKeyPress(event)) {\n          if (this._touchState === NOT_RESPONDER) {\n            start(event, false); // Listen to 'keyup' on document to account for situations where\n            // focus is moved to another element during 'keydown'.\n\n            document.addEventListener('keyup', keyupHandler);\n          }\n          var role = target.getAttribute('role');\n          var isSpacebarKey = key === ' ' || key === 'Spacebar';\n          var _isButtonRole = role === 'button' || role === 'menuitem';\n          if (isSpacebarKey && _isButtonRole) {\n            // Prevent spacebar scrolling the window\n            event.preventDefault();\n          }\n          event.stopPropagation();\n        }\n      },\n      onResponderGrant: event => start(event),\n      onResponderMove: event => {\n        if (this._config.onPressMove != null) {\n          this._config.onPressMove(event);\n        }\n        var touch = getTouchFromResponderEvent(event);\n        if (this._touchActivatePosition != null) {\n          var deltaX = this._touchActivatePosition.pageX - touch.pageX;\n          var deltaY = this._touchActivatePosition.pageY - touch.pageY;\n          if (Math.hypot(deltaX, deltaY) > 10) {\n            this._cancelLongPressDelayTimeout();\n          }\n        }\n      },\n      onResponderRelease: event => end(event),\n      onResponderTerminate: event => {\n        if (event.nativeEvent.type === 'selectionchange') {\n          this._selectionTerminated = true;\n        }\n        this._receiveSignal(RESPONDER_TERMINATED, event);\n      },\n      onResponderTerminationRequest: event => {\n        var _this$_config = this._config,\n          cancelable = _this$_config.cancelable,\n          disabled = _this$_config.disabled,\n          onLongPress = _this$_config.onLongPress; // If `onLongPress` is provided, don't terminate on `contextmenu` as default\n        // behavior will be prevented for non-mouse pointers.\n\n        if (!disabled && onLongPress != null && this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {\n          return false;\n        }\n        if (cancelable == null) {\n          return true;\n        }\n        return cancelable;\n      },\n      // NOTE: this diverges from react-native in 3 significant ways:\n      // * The `onPress` callback is not connected to the responder system (the native\n      //  `click` event must be used but is dispatched in many scenarios where no pointers\n      //   are on the screen.) Therefore, it's possible for `onPress` to be called without\n      //   `onPress{Start,End}` being called first.\n      // * The `onPress` callback is only be called on the first ancestor of the native\n      //   `click` target that is using the PressResponder.\n      // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.\n      onClick: event => {\n        var _this$_config2 = this._config,\n          disabled = _this$_config2.disabled,\n          onPress = _this$_config2.onPress;\n        if (!disabled) {\n          // If long press dispatched, cancel default click behavior.\n          // If the responder terminated because text was selected during the gesture,\n          // cancel the default click behavior.\n          event.stopPropagation();\n          if (this._longPressDispatched || this._selectionTerminated) {\n            event.preventDefault();\n          } else if (onPress != null && event.altKey === false) {\n            onPress(event);\n          }\n        } else {\n          if (isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n        }\n      },\n      // If `onLongPress` is provided and a touch pointer is being used, prevent the\n      // default context menu from opening.\n      onContextMenu: event => {\n        var _this$_config3 = this._config,\n          disabled = _this$_config3.disabled,\n          onLongPress = _this$_config3.onLongPress;\n        if (!disabled) {\n          if (onLongPress != null && this._isPointerTouch && !event.defaultPrevented) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        } else {\n          if (isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n        }\n      }\n    };\n  }\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   */\n\n  _receiveSignal(signal, event) {\n    var prevState = this._touchState;\n    var nextState = null;\n    if (Transitions[prevState] != null) {\n      nextState = Transitions[prevState][signal];\n    }\n    if (this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) {\n      return;\n    }\n    if (nextState == null || nextState === ERROR) {\n      console.error(\"PressResponder: Invalid signal \" + signal + \" for state \" + prevState + \" on responder\");\n    } else if (prevState !== nextState) {\n      this._performTransitionSideEffects(prevState, nextState, signal, event);\n      this._touchState = nextState;\n    }\n  }\n  /**\n   * Performs a transition between touchable states and identify any activations\n   * or deactivations (and callback invocations).\n   */\n\n  _performTransitionSideEffects(prevState, nextState, signal, event) {\n    if (isTerminalSignal(signal)) {\n      // Pressable suppression of contextmenu on windows.\n      // On Windows, the contextmenu is displayed after pointerup.\n      // https://github.com/necolas/react-native-web/issues/2296\n      setTimeout(() => {\n        this._isPointerTouch = false;\n      }, 0);\n      this._touchActivatePosition = null;\n      this._cancelLongPressDelayTimeout();\n    }\n    if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {\n      var onLongPress = this._config.onLongPress; // Long press is not supported for keyboards because 'click' can be dispatched\n      // immediately (and multiple times) after 'keydown'.\n\n      if (onLongPress != null && event.nativeEvent.key == null) {\n        onLongPress(event);\n        this._longPressDispatched = true;\n      }\n    }\n    var isPrevActive = isActiveSignal(prevState);\n    var isNextActive = isActiveSignal(nextState);\n    if (!isPrevActive && isNextActive) {\n      this._activate(event);\n    } else if (isPrevActive && !isNextActive) {\n      this._deactivate(event);\n    }\n    if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {\n      var _this$_config4 = this._config,\n        _onLongPress = _this$_config4.onLongPress,\n        onPress = _this$_config4.onPress;\n      if (onPress != null) {\n        var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;\n        if (!isPressCanceledByLongPress) {\n          // If we never activated (due to delays), activate and deactivate now.\n          if (!isNextActive && !isPrevActive) {\n            this._activate(event);\n            this._deactivate(event);\n          }\n        }\n      }\n    }\n    this._cancelPressDelayTimeout();\n  }\n  _activate(event) {\n    var _this$_config5 = this._config,\n      onPressChange = _this$_config5.onPressChange,\n      onPressStart = _this$_config5.onPressStart;\n    var touch = getTouchFromResponderEvent(event);\n    this._touchActivatePosition = {\n      pageX: touch.pageX,\n      pageY: touch.pageY\n    };\n    if (onPressStart != null) {\n      onPressStart(event);\n    }\n    if (onPressChange != null) {\n      onPressChange(true);\n    }\n  }\n  _deactivate(event) {\n    var _this$_config6 = this._config,\n      onPressChange = _this$_config6.onPressChange,\n      onPressEnd = _this$_config6.onPressEnd;\n    function end() {\n      if (onPressEnd != null) {\n        onPressEnd(event);\n      }\n      if (onPressChange != null) {\n        onPressChange(false);\n      }\n    }\n    var delayPressEnd = normalizeDelay(this._config.delayPressEnd);\n    if (delayPressEnd > 0) {\n      this._pressOutDelayTimeout = setTimeout(() => {\n        end();\n      }, delayPressEnd);\n    } else {\n      end();\n    }\n  }\n  _handleLongPress(event) {\n    if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {\n      this._receiveSignal(LONG_PRESS_DETECTED, event);\n    }\n  }\n  _cancelLongPressDelayTimeout() {\n    if (this._longPressDelayTimeout != null) {\n      clearTimeout(this._longPressDelayTimeout);\n      this._longPressDelayTimeout = null;\n    }\n  }\n  _cancelPressDelayTimeout() {\n    if (this._pressDelayTimeout != null) {\n      clearTimeout(this._pressDelayTimeout);\n      this._pressDelayTimeout = null;\n    }\n  }\n  _cancelPressOutDelayTimeout() {\n    if (this._pressOutDelayTimeout != null) {\n      clearTimeout(this._pressOutDelayTimeout);\n      this._pressOutDelayTimeout = null;\n    }\n  }\n}\nfunction normalizeDelay(delay, min, fallback) {\n  if (min === void 0) {\n    min = 0;\n  }\n  if (fallback === void 0) {\n    fallback = 0;\n  }\n  return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);\n}\nfunction getTouchFromResponderEvent(event) {\n  var _event$nativeEvent = event.nativeEvent,\n    changedTouches = _event$nativeEvent.changedTouches,\n    touches = _event$nativeEvent.touches;\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n  return event.nativeEvent;\n}","map":{"version":3,"names":["DELAY","ERROR","LONG_PRESS_DETECTED","NOT_RESPONDER","RESPONDER_ACTIVE_LONG_PRESS_START","RESPONDER_ACTIVE_PRESS_START","RESPONDER_INACTIVE_PRESS_START","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","Transitions","Object","freeze","isActiveSignal","signal","isButtonRole","element","getAttribute","isPressStartSignal","isTerminalSignal","isValidKeyPress","event","key","target","role","isSpacebar","DEFAULT_LONG_PRESS_DELAY_MS","DEFAULT_PRESS_DELAY_MS","PressResponder","constructor","config","_eventHandlers","_isPointerTouch","_longPressDelayTimeout","_longPressDispatched","_pressDelayTimeout","_pressOutDelayTimeout","_touchState","configure","_config","reset","_cancelLongPressDelayTimeout","_cancelPressDelayTimeout","_cancelPressOutDelayTimeout","getEventHandlers","_createEventHandlers","start","shouldDelay","persist","_selectionTerminated","nativeEvent","type","_receiveSignal","delayPressStart","normalizeDelay","setTimeout","delayLongPress","_handleLongPress","end","keyupHandler","onPress","document","removeEventListener","elementType","tagName","toLowerCase","isNativeInteractiveElement","onStartShouldSetResponder","disabled","currentTarget","stopPropagation","onKeyDown","addEventListener","isSpacebarKey","_isButtonRole","preventDefault","onResponderGrant","onResponderMove","onPressMove","touch","getTouchFromResponderEvent","_touchActivatePosition","deltaX","pageX","deltaY","pageY","Math","hypot","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","_this$_config","cancelable","onLongPress","onClick","_this$_config2","altKey","onContextMenu","_this$_config3","defaultPrevented","prevState","nextState","console","error","_performTransitionSideEffects","isPrevActive","isNextActive","_activate","_deactivate","_this$_config4","_onLongPress","isPressCanceledByLongPress","_this$_config5","onPressChange","onPressStart","_this$_config6","onPressEnd","delayPressEnd","clearTimeout","delay","min","fallback","max","_event$nativeEvent","changedTouches","touches","length"],"sources":["C:/Users/dlfrn/Downloads/myToyProj/toyProject/FrontEnd/alcohol-app/node_modules/react-native-web/dist/modules/usePressEvents/PressResponder.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar DELAY = 'DELAY';\nvar ERROR = 'ERROR';\nvar LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';\nvar NOT_RESPONDER = 'NOT_RESPONDER';\nvar RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';\nvar RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';\nvar RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';\nvar RESPONDER_GRANT = 'RESPONDER_GRANT';\nvar RESPONDER_RELEASE = 'RESPONDER_RELEASE';\nvar RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';\nvar Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: ERROR,\n    RESPONDER_TERMINATED: ERROR,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_START: {\n    DELAY: RESPONDER_ACTIVE_PRESS_START,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  ERROR: {\n    DELAY: NOT_RESPONDER,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: NOT_RESPONDER\n  }\n});\n\nvar isActiveSignal = signal => signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n\nvar isButtonRole = element => element.getAttribute('role') === 'button';\n\nvar isPressStartSignal = signal => signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n\nvar isTerminalSignal = signal => signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;\n\nvar isValidKeyPress = event => {\n  var key = event.key,\n      target = event.target;\n  var role = target.getAttribute('role');\n  var isSpacebar = key === ' ' || key === 'Spacebar';\n  return key === 'Enter' || isSpacebar && role === 'button';\n};\n\nvar DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50\n\nvar DEFAULT_PRESS_DELAY_MS = 50;\n/**\n * =========================== PressResponder Tutorial ===========================\n *\n * The `PressResponder` class helps you create press interactions by analyzing the\n * geometry of elements and observing when another responder (e.g. ScrollView)\n * has stolen the touch lock. It offers hooks for your component to provide\n * interaction feedback to the user:\n *\n * - When a press has activated (e.g. highlight an element)\n * - When a press has deactivated (e.g. un-highlight an element)\n * - When a press sould trigger an action, meaning it activated and deactivated\n *   while within the geometry of the element without the lock being stolen.\n *\n * A high quality interaction isn't as simple as you might think. There should\n * be a slight delay before activation. Moving your finger beyond an element's\n * bounds should trigger deactivation, but moving the same finger back within an\n * element's bounds should trigger reactivation.\n *\n * In order to use `PressResponder`, do the following:\n *\n *     const pressResponder = new PressResponder(config);\n *\n * 2. Choose the rendered component who should collect the press events. On that\n *    element, spread `pressability.getEventHandlers()` into its props.\n *\n *    return (\n *      <View {...this.state.pressResponder.getEventHandlers()} />\n *    );\n *\n * 3. Reset `PressResponder` when your component unmounts.\n *\n *    componentWillUnmount() {\n *      this.state.pressResponder.reset();\n *    }\n *\n * ==================== Implementation Details ====================\n *\n * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n * # Geometry\n *\n *  ┌────────────────────────┐\n *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`.\n *  │  │  ┌────────────┐  │  │\n *  │  │  │ VisualRect │  │  │\n *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time\n *  │  │    HitRect       │  │   before letting up, `VisualRect` activates.\n *  │  └──────────────────┘  │\n *  │       Out Region   o   │\n *  └────────────────────│───┘\n *                       └────── When the press is released outside the `HitRect`,\n *                               the responder is NOT eligible for a \"press\".\n *\n * # State Machine\n *\n * ┌───────────────┐ ◀──── RESPONDER_RELEASE\n * │ NOT_RESPONDER │\n * └───┬───────────┘ ◀──── RESPONDER_TERMINATED\n *     │\n *     │ RESPONDER_GRANT (HitRect)\n *     │\n *     ▼\n * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐\n * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │\n * │ PRESS_START         ├────────▶ │ PRESS_START       ├────────────▶ │ LONG_PRESS_START  │\n * └─────────────────────┘          └───────────────────┘              └───────────────────┘\n *\n * T + DELAY => LONG_PRESS_DELAY + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the invocation of `onLongPress`. Only when the browser produces a\n * `click` event is `onPress` invoked.\n */\n\nexport default class PressResponder {\n  constructor(config) {\n    this._eventHandlers = null;\n    this._isPointerTouch = false;\n    this._longPressDelayTimeout = null;\n    this._longPressDispatched = false;\n    this._pressDelayTimeout = null;\n    this._pressOutDelayTimeout = null;\n    this._touchState = NOT_RESPONDER;\n    this.configure(config);\n  }\n\n  configure(config) {\n    this._config = config;\n  }\n  /**\n   * Resets any pending timers. This should be called on unmount.\n   */\n\n\n  reset() {\n    this._cancelLongPressDelayTimeout();\n\n    this._cancelPressDelayTimeout();\n\n    this._cancelPressOutDelayTimeout();\n  }\n  /**\n   * Returns a set of props to spread into the interactive element.\n   */\n\n\n  getEventHandlers() {\n    if (this._eventHandlers == null) {\n      this._eventHandlers = this._createEventHandlers();\n    }\n\n    return this._eventHandlers;\n  }\n\n  _createEventHandlers() {\n    var start = (event, shouldDelay) => {\n      event.persist();\n\n      this._cancelPressOutDelayTimeout();\n\n      this._longPressDispatched = false;\n      this._selectionTerminated = false;\n      this._touchState = NOT_RESPONDER;\n      this._isPointerTouch = event.nativeEvent.type === 'touchstart';\n\n      this._receiveSignal(RESPONDER_GRANT, event);\n\n      var delayPressStart = normalizeDelay(this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);\n\n      if (shouldDelay !== false && delayPressStart > 0) {\n        this._pressDelayTimeout = setTimeout(() => {\n          this._receiveSignal(DELAY, event);\n        }, delayPressStart);\n      } else {\n        this._receiveSignal(DELAY, event);\n      }\n\n      var delayLongPress = normalizeDelay(this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);\n      this._longPressDelayTimeout = setTimeout(() => {\n        this._handleLongPress(event);\n      }, delayLongPress + delayPressStart);\n    };\n\n    var end = event => {\n      this._receiveSignal(RESPONDER_RELEASE, event);\n    };\n\n    var keyupHandler = event => {\n      var onPress = this._config.onPress;\n      var target = event.target;\n\n      if (this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {\n        end(event);\n        document.removeEventListener('keyup', keyupHandler);\n        var role = target.getAttribute('role');\n        var elementType = target.tagName.toLowerCase();\n        var isNativeInteractiveElement = role === 'link' || elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea';\n\n        if (onPress != null && !isNativeInteractiveElement) {\n          onPress(event);\n        }\n      }\n    };\n\n    return {\n      onStartShouldSetResponder: event => {\n        var disabled = this._config.disabled;\n\n        if (disabled && isButtonRole(event.currentTarget)) {\n          event.stopPropagation();\n        }\n\n        if (disabled == null) {\n          return true;\n        }\n\n        return !disabled;\n      },\n      onKeyDown: event => {\n        var disabled = this._config.disabled;\n        var key = event.key,\n            target = event.target;\n\n        if (!disabled && isValidKeyPress(event)) {\n          if (this._touchState === NOT_RESPONDER) {\n            start(event, false); // Listen to 'keyup' on document to account for situations where\n            // focus is moved to another element during 'keydown'.\n\n            document.addEventListener('keyup', keyupHandler);\n          }\n\n          var role = target.getAttribute('role');\n          var isSpacebarKey = key === ' ' || key === 'Spacebar';\n\n          var _isButtonRole = role === 'button' || role === 'menuitem';\n\n          if (isSpacebarKey && _isButtonRole) {\n            // Prevent spacebar scrolling the window\n            event.preventDefault();\n          }\n\n          event.stopPropagation();\n        }\n      },\n      onResponderGrant: event => start(event),\n      onResponderMove: event => {\n        if (this._config.onPressMove != null) {\n          this._config.onPressMove(event);\n        }\n\n        var touch = getTouchFromResponderEvent(event);\n\n        if (this._touchActivatePosition != null) {\n          var deltaX = this._touchActivatePosition.pageX - touch.pageX;\n          var deltaY = this._touchActivatePosition.pageY - touch.pageY;\n\n          if (Math.hypot(deltaX, deltaY) > 10) {\n            this._cancelLongPressDelayTimeout();\n          }\n        }\n      },\n      onResponderRelease: event => end(event),\n      onResponderTerminate: event => {\n        if (event.nativeEvent.type === 'selectionchange') {\n          this._selectionTerminated = true;\n        }\n\n        this._receiveSignal(RESPONDER_TERMINATED, event);\n      },\n      onResponderTerminationRequest: event => {\n        var _this$_config = this._config,\n            cancelable = _this$_config.cancelable,\n            disabled = _this$_config.disabled,\n            onLongPress = _this$_config.onLongPress; // If `onLongPress` is provided, don't terminate on `contextmenu` as default\n        // behavior will be prevented for non-mouse pointers.\n\n        if (!disabled && onLongPress != null && this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {\n          return false;\n        }\n\n        if (cancelable == null) {\n          return true;\n        }\n\n        return cancelable;\n      },\n      // NOTE: this diverges from react-native in 3 significant ways:\n      // * The `onPress` callback is not connected to the responder system (the native\n      //  `click` event must be used but is dispatched in many scenarios where no pointers\n      //   are on the screen.) Therefore, it's possible for `onPress` to be called without\n      //   `onPress{Start,End}` being called first.\n      // * The `onPress` callback is only be called on the first ancestor of the native\n      //   `click` target that is using the PressResponder.\n      // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.\n      onClick: event => {\n        var _this$_config2 = this._config,\n            disabled = _this$_config2.disabled,\n            onPress = _this$_config2.onPress;\n\n        if (!disabled) {\n          // If long press dispatched, cancel default click behavior.\n          // If the responder terminated because text was selected during the gesture,\n          // cancel the default click behavior.\n          event.stopPropagation();\n\n          if (this._longPressDispatched || this._selectionTerminated) {\n            event.preventDefault();\n          } else if (onPress != null && event.altKey === false) {\n            onPress(event);\n          }\n        } else {\n          if (isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n        }\n      },\n      // If `onLongPress` is provided and a touch pointer is being used, prevent the\n      // default context menu from opening.\n      onContextMenu: event => {\n        var _this$_config3 = this._config,\n            disabled = _this$_config3.disabled,\n            onLongPress = _this$_config3.onLongPress;\n\n        if (!disabled) {\n          if (onLongPress != null && this._isPointerTouch && !event.defaultPrevented) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        } else {\n          if (isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n        }\n      }\n    };\n  }\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   */\n\n\n  _receiveSignal(signal, event) {\n    var prevState = this._touchState;\n    var nextState = null;\n\n    if (Transitions[prevState] != null) {\n      nextState = Transitions[prevState][signal];\n    }\n\n    if (this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) {\n      return;\n    }\n\n    if (nextState == null || nextState === ERROR) {\n      console.error(\"PressResponder: Invalid signal \" + signal + \" for state \" + prevState + \" on responder\");\n    } else if (prevState !== nextState) {\n      this._performTransitionSideEffects(prevState, nextState, signal, event);\n\n      this._touchState = nextState;\n    }\n  }\n  /**\n   * Performs a transition between touchable states and identify any activations\n   * or deactivations (and callback invocations).\n   */\n\n\n  _performTransitionSideEffects(prevState, nextState, signal, event) {\n    if (isTerminalSignal(signal)) {\n      // Pressable suppression of contextmenu on windows.\n      // On Windows, the contextmenu is displayed after pointerup.\n      // https://github.com/necolas/react-native-web/issues/2296\n      setTimeout(() => {\n        this._isPointerTouch = false;\n      }, 0);\n      this._touchActivatePosition = null;\n\n      this._cancelLongPressDelayTimeout();\n    }\n\n    if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {\n      var onLongPress = this._config.onLongPress; // Long press is not supported for keyboards because 'click' can be dispatched\n      // immediately (and multiple times) after 'keydown'.\n\n      if (onLongPress != null && event.nativeEvent.key == null) {\n        onLongPress(event);\n        this._longPressDispatched = true;\n      }\n    }\n\n    var isPrevActive = isActiveSignal(prevState);\n    var isNextActive = isActiveSignal(nextState);\n\n    if (!isPrevActive && isNextActive) {\n      this._activate(event);\n    } else if (isPrevActive && !isNextActive) {\n      this._deactivate(event);\n    }\n\n    if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {\n      var _this$_config4 = this._config,\n          _onLongPress = _this$_config4.onLongPress,\n          onPress = _this$_config4.onPress;\n\n      if (onPress != null) {\n        var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;\n\n        if (!isPressCanceledByLongPress) {\n          // If we never activated (due to delays), activate and deactivate now.\n          if (!isNextActive && !isPrevActive) {\n            this._activate(event);\n\n            this._deactivate(event);\n          }\n        }\n      }\n    }\n\n    this._cancelPressDelayTimeout();\n  }\n\n  _activate(event) {\n    var _this$_config5 = this._config,\n        onPressChange = _this$_config5.onPressChange,\n        onPressStart = _this$_config5.onPressStart;\n    var touch = getTouchFromResponderEvent(event);\n    this._touchActivatePosition = {\n      pageX: touch.pageX,\n      pageY: touch.pageY\n    };\n\n    if (onPressStart != null) {\n      onPressStart(event);\n    }\n\n    if (onPressChange != null) {\n      onPressChange(true);\n    }\n  }\n\n  _deactivate(event) {\n    var _this$_config6 = this._config,\n        onPressChange = _this$_config6.onPressChange,\n        onPressEnd = _this$_config6.onPressEnd;\n\n    function end() {\n      if (onPressEnd != null) {\n        onPressEnd(event);\n      }\n\n      if (onPressChange != null) {\n        onPressChange(false);\n      }\n    }\n\n    var delayPressEnd = normalizeDelay(this._config.delayPressEnd);\n\n    if (delayPressEnd > 0) {\n      this._pressOutDelayTimeout = setTimeout(() => {\n        end();\n      }, delayPressEnd);\n    } else {\n      end();\n    }\n  }\n\n  _handleLongPress(event) {\n    if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {\n      this._receiveSignal(LONG_PRESS_DETECTED, event);\n    }\n  }\n\n  _cancelLongPressDelayTimeout() {\n    if (this._longPressDelayTimeout != null) {\n      clearTimeout(this._longPressDelayTimeout);\n      this._longPressDelayTimeout = null;\n    }\n  }\n\n  _cancelPressDelayTimeout() {\n    if (this._pressDelayTimeout != null) {\n      clearTimeout(this._pressDelayTimeout);\n      this._pressDelayTimeout = null;\n    }\n  }\n\n  _cancelPressOutDelayTimeout() {\n    if (this._pressOutDelayTimeout != null) {\n      clearTimeout(this._pressOutDelayTimeout);\n      this._pressOutDelayTimeout = null;\n    }\n  }\n\n}\n\nfunction normalizeDelay(delay, min, fallback) {\n  if (min === void 0) {\n    min = 0;\n  }\n\n  if (fallback === void 0) {\n    fallback = 0;\n  }\n\n  return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);\n}\n\nfunction getTouchFromResponderEvent(event) {\n  var _event$nativeEvent = event.nativeEvent,\n      changedTouches = _event$nativeEvent.changedTouches,\n      touches = _event$nativeEvent.touches;\n\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n\n  return event.nativeEvent;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}