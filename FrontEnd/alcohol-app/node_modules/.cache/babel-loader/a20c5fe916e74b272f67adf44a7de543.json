{"ast":null,"code":"/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar dataUriPattern = /^data:/;\nexport class ImageUriCache {\n  static has(uri) {\n    var entries = ImageUriCache._entries;\n    var isDataUri = dataUriPattern.test(uri);\n    return isDataUri || Boolean(entries[uri]);\n  }\n\n  static add(uri) {\n    var entries = ImageUriCache._entries;\n    var lastUsedTimestamp = Date.now();\n\n    if (entries[uri]) {\n      entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n      entries[uri].refCount += 1;\n    } else {\n      entries[uri] = {\n        lastUsedTimestamp,\n        refCount: 1\n      };\n    }\n  }\n\n  static remove(uri) {\n    var entries = ImageUriCache._entries;\n\n    if (entries[uri]) {\n      entries[uri].refCount -= 1;\n    } // Free up entries when the cache is \"full\"\n\n\n    ImageUriCache._cleanUpIfNeeded();\n  }\n\n  static _cleanUpIfNeeded() {\n    var entries = ImageUriCache._entries;\n    var imageUris = Object.keys(entries);\n\n    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n      var leastRecentlyUsedKey;\n      var leastRecentlyUsedEntry;\n      imageUris.forEach(uri => {\n        var entry = entries[uri];\n\n        if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n          leastRecentlyUsedKey = uri;\n          leastRecentlyUsedEntry = entry;\n        }\n      });\n\n      if (leastRecentlyUsedKey) {\n        delete entries[leastRecentlyUsedKey];\n      }\n    }\n  }\n\n}\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort(requestId) {\n    var image = requests[\"\" + requestId];\n\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n\n  getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n\n    function callback() {\n      var image = requests[\"\" + requestId];\n\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n            naturalWidth = image.naturalWidth;\n\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n\n  has(uri) {\n    return ImageUriCache.has(uri);\n  },\n\n  load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n\n    image.onload = e => {\n      // avoid blocking the main thread\n      var onDecode = () => onLoad({\n        nativeEvent: e\n      });\n\n      if (typeof image.decode === 'function') {\n        // Safari currently throws exceptions when decoding svgs.\n        // We want to catch that error and allow the load handler\n        // to be forwarded to the onLoad handler in this case\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n\n  prefetch(uri) {\n    return new Promise((resolve, reject) => {\n      ImageLoader.load(uri, () => {\n        // Add the uri to the cache so it can be immediately displayed when used\n        // but also immediately remove it to correctly reflect that it has no active references\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n\n  queryCache(uris) {\n    var result = {};\n    uris.forEach(u => {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n\n};\nexport default ImageLoader;","map":{"version":3,"names":["dataUriPattern","ImageUriCache","has","uri","entries","_entries","isDataUri","test","Boolean","add","lastUsedTimestamp","Date","now","refCount","remove","_cleanUpIfNeeded","imageUris","Object","keys","length","_maximumEntries","leastRecentlyUsedKey","leastRecentlyUsedEntry","forEach","entry","id","requests","ImageLoader","abort","requestId","image","onerror","onload","getSize","success","failure","complete","interval","setInterval","callback","load","errorCallback","naturalHeight","naturalWidth","clearInterval","onLoad","onError","window","Image","e","onDecode","nativeEvent","decode","then","setTimeout","src","prefetch","Promise","resolve","reject","queryCache","uris","result","u"],"sources":["/Users/ilkwon_choi/Downloads/Alcohol/FrontEnd/alcohol-app/node_modules/react-native-web/dist/modules/ImageLoader/index.js"],"sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar dataUriPattern = /^data:/;\nexport class ImageUriCache {\n  static has(uri) {\n    var entries = ImageUriCache._entries;\n    var isDataUri = dataUriPattern.test(uri);\n    return isDataUri || Boolean(entries[uri]);\n  }\n\n  static add(uri) {\n    var entries = ImageUriCache._entries;\n    var lastUsedTimestamp = Date.now();\n\n    if (entries[uri]) {\n      entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n      entries[uri].refCount += 1;\n    } else {\n      entries[uri] = {\n        lastUsedTimestamp,\n        refCount: 1\n      };\n    }\n  }\n\n  static remove(uri) {\n    var entries = ImageUriCache._entries;\n\n    if (entries[uri]) {\n      entries[uri].refCount -= 1;\n    } // Free up entries when the cache is \"full\"\n\n\n    ImageUriCache._cleanUpIfNeeded();\n  }\n\n  static _cleanUpIfNeeded() {\n    var entries = ImageUriCache._entries;\n    var imageUris = Object.keys(entries);\n\n    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n      var leastRecentlyUsedKey;\n      var leastRecentlyUsedEntry;\n      imageUris.forEach(uri => {\n        var entry = entries[uri];\n\n        if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n          leastRecentlyUsedKey = uri;\n          leastRecentlyUsedEntry = entry;\n        }\n      });\n\n      if (leastRecentlyUsedKey) {\n        delete entries[leastRecentlyUsedKey];\n      }\n    }\n  }\n\n}\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort(requestId) {\n    var image = requests[\"\" + requestId];\n\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n\n  getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n\n    function callback() {\n      var image = requests[\"\" + requestId];\n\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n            naturalWidth = image.naturalWidth;\n\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n\n  has(uri) {\n    return ImageUriCache.has(uri);\n  },\n\n  load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n\n    image.onload = e => {\n      // avoid blocking the main thread\n      var onDecode = () => onLoad({\n        nativeEvent: e\n      });\n\n      if (typeof image.decode === 'function') {\n        // Safari currently throws exceptions when decoding svgs.\n        // We want to catch that error and allow the load handler\n        // to be forwarded to the onLoad handler in this case\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n\n  prefetch(uri) {\n    return new Promise((resolve, reject) => {\n      ImageLoader.load(uri, () => {\n        // Add the uri to the cache so it can be immediately displayed when used\n        // but also immediately remove it to correctly reflect that it has no active references\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n\n  queryCache(uris) {\n    var result = {};\n    uris.forEach(u => {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n\n};\nexport default ImageLoader;"],"mappings":"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"},"metadata":{},"sourceType":"module"}